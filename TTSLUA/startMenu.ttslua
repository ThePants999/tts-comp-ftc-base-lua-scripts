-- FTC-GUID: 738804
-- CONTENT:
-- size changer manager
-- deploy zones manager
-- objectives manager
-- game manager

keepForTerrainEditor = true

mat_GUID = Global.getVar("mat_GUID")

function onLoad(saved_data)
    --self.setPosition({40,-4,0})
    self.setRotation({0,270,0})
    -- load from saved
    if saved_data ~= "" then
        local loaded_data = JSON.decode(saved_data)
        gameMode = loaded_data.svgameMode
        inGame = loaded_data.svinGame
        currentTurn = loaded_data.svcurrentTurn
        currentPhase = loaded_data.svcurrentPhase
        mapSizeSelected = loaded_data.svmapSizeSelected
        sizeConfirmed = loaded_data.svsizeConfirmed
        deploySelected = loaded_data.svdeploySelected
    end

    mat = getObjectFromGUID(mat_GUID)
    if simulation then print("THIS IS "..currentTurn.." TURN") end
    -- DEPLOY MENU VARIABLES

    -- REST OF CODE
    redTurnCounter = getObjectFromGUID(Global.getVar("redTurnCounter_GUID"))
    blueTurnCounter = getObjectFromGUID(Global.getVar("blueTurnCounter_GUID"))
    gameTurnCounter = getObjectFromGUID(Global.getVar("gameTurnCounter_GUID"))
    redCpCounter = getObjectFromGUID(Global.getVar("redCPCounter_GUID"))
    blueCpCounter = getObjectFromGUID(Global.getVar("blueCPCounter_GUID"))
    if inGame == false then
        --broadcastToAll("The mod will keep track of how many times a game is started or a map is exported.\nNo other data will be sent!", "Orange")
        Notes.setNotes(notePadTxt)
    else
        Notes.setNotes("")
    end
    if deploymentIngamePlaced == true then
        deployIngameBtn.label = deployIngameLblOpen
    else
        deployIngameBtn.label = deployIngameLblClosed
    end
    if areaPlaced == true then
        areaBtn.label = areaLblOpen
    else
        areaBtn.label = areaLblClosed
    end
    gameTurnCounter.call("checkGameEnd")
    writeMenus()
    if not inGame then
        makeAnnouncement()
    end
end

function onSave()
    saved_data = JSON.encode({
        svinGame = inGame,
        svgameMode = gameMode,
        svcurrentTurn = currentTurn,
        svcurrentPhase = currentPhase,
        svmapSizeSelected = mapSizeSelected,
        svsizeConfirmed = sizeConfirmed,
        svdeploySelected = deploySelected
    })
    --saved_data = ""
    return saved_data
end

function makeAnnouncement()
    local features={
    "2.50: TENTH EDITION YOOOOOOOO",
    "2.51:",
    "improved card graphics",
    "incorporated GW's card errata",
    "added button for random tournament mission",
    "further token improvements",
    "added Leviathan mission reference card",
    "added instructions for using cards",
    "added bag of datasheets",
    "2.52: fixed chess clock and duplicated primary card"
    }
    printToAll("NEW FEATURES:", "Yellow")
    for i, new in ipairs(features) do
        printToAll("- "..new, "Yellow")
    end
end

-- SIZE CHANGER MANAGER
positionValue={0,-9.52,0}
sizeData={
    {id=1, name='C o m b a t     P a t r o l - 44" x 30"', scale={1.22,1,0.83}, defaultObjectives=0},
    {id=2, name='Incursion / Strike Force - 44" x 60"', scale={0.83*2,1,1.22}, defaultObjectives=0},
    {id=3, name='O n s l a u g h t - 44" x 90"', scale={0.83*3,1,1.22}, defaultObjectives=0},
}

menuSizeX = 0
menuSizeY = 5
menuSizeZ = 25
arrowOffset=9.5

mapSizeSelected=2
numberSizes=#sizeData
sizeConfirmed=false

sizeMenuBtn={
    index=1, label="S E L E C T     B A T T L E F I E L D     S I Z E", click_function="none", function_owner=self,
    position={menuSizeX, menuSizeY ,menuSizeZ-2.05}, rotation={0,0,0}, height=450, width=8000, scale = {1.3,1.3,1.3},
    font_size=300, color={0,0,0}, font_color={1,1,1}
}

sizeBtn={
    index= i, label="Zone", click_function="none", function_owner=self,
    position={-menuSizeX, menuSizeY ,menuSizeZ}, rotation={0,0,0}, height=450, width=6000,scale = {1.3,1.3,1.3},
    font_size=300, color={0.6,0.6,0.6}, font_color={0,0,0}
}
sizeUpBtn={
    index=1, label="->", click_function="sizeUp", function_owner=self,
    position={-menuSizeX+arrowOffset, menuSizeY ,menuSizeZ}, rotation={0,0,0}, height=450, width=800,scale = {1.3,1.3,1.3},
    font_size=300, color={0,0,0}, font_color={1,1,1}
}
sizeDownBtn={
    index=1, label="<-", click_function="sizeDown", function_owner=self,
    position={-menuSizeX-arrowOffset, menuSizeY ,menuSizeZ}, rotation={0,0,0}, height=450, width=800,scale = {1.3,1.3,1.3},
    font_size=300, color={0,0,0}, font_color={1,1,1}
}
confirmBtn={
    index= i, label="C O N F I R M\nFOR GAMING", click_function="confirmSizeGame", function_owner=self,
    position={-menuSizeX, menuSizeY ,menuSizeZ+3.5}, rotation={0,0,0}, height=1400, width=4400, scale = {1.3,1.3,1.3},
    font_size=500, color={0,0.7,0}, font_color={0,0,0}
}
confirmBtn2={
    index= i, label="C O N F I R M\nFOR MAP MAKING", click_function="confirmSizeTerrain", function_owner=self,
    position={-menuSizeX, menuSizeY ,menuSizeZ+7.5}, rotation={0,0,0}, height=1400, width=4400, scale = {1.3,1.3,1.3},
    font_size=500, color={0.7,0,0}, font_color={0,0,0}
}

function refreshMat()
    mat = getObjectFromGUID(mat_GUID)
end

function writeSizeMenu()
    self.clearButtons()
    if sizeConfirmed then
        return
    end
    self.createButton(sizeMenuBtn)
    sizeBtn.label=sizeData[mapSizeSelected].name
    self.createButton(sizeBtn)
    self.createButton(sizeUpBtn)
    self.createButton(sizeDownBtn)
    self.createButton(confirmBtn)
    self.createButton(confirmBtn2)
    mat.setScale(sizeData[mapSizeSelected].scale)
    mat.setPosition(positionValue)
end

function sizeUp()
    sizeUpDown(1)
end

function sizeDown()
    sizeUpDown(-1)
end

function sizeUpDown(increment)
    mapSizeSelected=mapSizeSelected+increment
    if mapSizeSelected > #sizeData then
        mapSizeSelected=1
    end
    if mapSizeSelected < 1 then
        mapSizeSelected=#sizeData
    end
    updateDeployObjectivesSelection()
    writeMenus()
end

function confirmSizeGame()
    confirmSizeMat("game")
    --deleting the Combat Patrol Mission book unless on the appropriate map size
    if sizeData[mapSizeSelected].id ~= 1 then
        cpbook = getObjectFromGUID(Global.getVar("CPMissionBook_GUID"))
        destroyObject(cpbook)
    end
end

function confirmSizeTerrain()
    confirmSizeMat("terrain")
end

function confirmSizeMat(type)
    gameMode= type
    sizeConfirmed=true
    mat.setScale(sizeData[mapSizeSelected].scale)
    self.setRotation({0,270,0})
    writeMenus()
    if gameMode == "game" then
    end
    if gameMode == "terrain" then
        switchToTerrainEditor()
    end
end

function updateDeployObjectivesSelection()
    deploySelected = #DeployZonesData
end

function switchToTerrainEditor()
    printToAll("Deleting unnecessary things.\nPLEASE WAIT..", "Yellow")
    local pos={}
    for i, obj in ipairs(getAllObjects()) do
        pos=obj.getPosition()
        if ((pos.y > -8 and pos.y < 0.36) or pos.y > 0.71) and not obj.getVar("keepForTerrainEditor") then
            obj.destroy()
        end
    end
    Global.setVectorLines({})
    printToAll("DONE!", "Yellow")
end
-- END size changer

objectivesData = {
--Leviathan Missions
    {id = 12, name = "(Hammer and Anvil", objectives = {
        {type = "fixed", pos={0, objectivesOffset, 0}},
        {type = "fixed", pos={20, objectivesOffset, 0}},
        {type = "fixed", pos={-20, objectivesOffset, 0}},
        {type = "fixed", pos={0, objectivesOffset, 16}},
        {type = "fixed", pos={0, objectivesOffset, -16}}}},
    {id = 13, name = "Dawn of War", objectives = {
        {type = "fixed", pos={0, objectivesOffset, 0}},
        {type = "fixed", pos={20, objectivesOffset, 0}},
        {type = "fixed", pos={-20, objectivesOffset, 0}},
        {type = "fixed", pos={0, objectivesOffset, 16}},
        {type = "fixed", pos={0, objectivesOffset, -16}}}},
    {id = 14, name = "Sweeping Engagement", objectives = {
        {type = "fixed", pos={0, objectivesOffset, 0}},
        {type = "fixed", pos={12, objectivesOffset, 16}},
        {type = "fixed", pos={20, objectivesOffset, -8}},
        {type = "fixed", pos={-12, objectivesOffset, -16}},
        {type = "fixed", pos={-20, objectivesOffset, 8}}}},
    {id = 15, name = "Search and Destroy", objectives = {
        {type = "fixed", pos={0, objectivesOffset, 0}},
        {type = "fixed", pos={16, objectivesOffset, 12}},
        {type = "fixed", pos={16, objectivesOffset, -12}},
        {type = "fixed", pos={-16, objectivesOffset, 12}},
        {type = "fixed", pos={-16, objectivesOffset, -12}}}},
    {id = 16, name = "Crucible of Battle", objectives = {
        {type = "fixed", pos={0, objectivesOffset, 0}},
        {type = "fixed", pos={10, objectivesOffset, -14}},
        {type = "fixed", pos={16, objectivesOffset, 12}},
        {type = "fixed", pos={-10, objectivesOffset, 14}},
        {type = "fixed", pos={-16, objectivesOffset, -12}}}},
--Combat Patrol Missions
    {id = 17, name = "(CP) Clash of Patrols", objectives = {
        {type = "fixed", pos={10, objectivesOffset, 0}},
        {type = "fixed", pos={-10, objectivesOffset, 0}},
        {type = "fixed", pos={0, objectivesOffset, 6}},
        {type = "fixed", pos={0, objectivesOffset, -6}}}},
    {id = 18, name = "(CP) Archeotech Recovery", objectives = {
        {type = "fixed", pos={0, objectivesOffset, 0}},
        {type = "fixed", pos={16, objectivesOffset, 8}},
        {type = "fixed", pos={-16, objectivesOffset, -8}},
        {type = "fixed", pos={8, objectivesOffset, -8}},
        {type = "fixed", pos={-8, objectivesOffset, 8}}}},
    {id = 19, name = "(CP) Forward Outpost", objectives = {
        {type = "fixed", pos={16, objectivesOffset, 0}},
        {type = "fixed", pos={-16, objectivesOffset, 0}},
        {type = "fixed", pos={0, objectivesOffset, 8}},
        {type = "fixed", pos={0, objectivesOffset, -8}}}},
    {id = 20, name = "(CP) Scorched Earth", objectives = {
        {type = "fixed", pos={10, objectivesOffset, -4}},
        {type = "fixed", pos={-10, objectivesOffset, 4}},
        {type = "fixed", pos={0, objectivesOffset, 6}},
        {type = "fixed", pos={0, objectivesOffset, -6}}}},
    {id = 21, name = "(CP) Sweeping Raid", objectives = {
        {type = "fixed", pos={16, objectivesOffset, 6}},
        {type = "fixed", pos={-16, objectivesOffset, -6}},
        {type = "fixed", pos={3, objectivesOffset, -9}},
        {type = "fixed", pos={-3, objectivesOffset, 9}}}},
    {id = 22, name = "(CP) Display of Might", objectives = {
        {type = "fixed", pos={14, objectivesOffset, 0}},
        {type = "fixed", pos={-14, objectivesOffset, 0}},
        {type = "fixed", pos={0, objectivesOffset, 8}},
        {type = "fixed", pos={0, objectivesOffset, -8}}}},
    {id = 0, name = "None", objectives = {}},
}

-- DEPLOY ZONES MANAGER
DeployZonesData = {
    --Leviathan Missions
    {name = "Hammer and Anvil", objectivesID = 12, draw = {
        --[[1]]{type = "line", color = "Red", position = "x", fromCenter = 12 },
        --[[2]]{type = "line", color = "Teal", position = "-x", fromCenter = 12, fromEdge = 0}}},
    {name = "Dawn of War", objectivesID = 13, draw = {
        --[[1]]{type = "line", color = "Teal", position = "-z", fromCenter = 12 },
        --[[2]]{type = "line", color = "Red", position = "z", fromCenter = 12, fromEdge = 0}}},
    {name = "Sweeping Engagement", objectivesID = 14, draw = {
        --[[1]]{type = "triangle", color = "Red", position = "z"},
        --[[2]]{type = "triangle", color = "Teal", position = "-z"}}},
    {name = "Search and Destroy", objectivesID = 15, draw = {
        --[[1]]{type = "quarter", color = "Teal", position = "-x-z", fromCenter = 9},
        --[[2]]{type = "quarter", color = "Red", position = "xz", fromCenter = 9},
        --[[3]]{type = "circle", color = "White", fromCenter = 9}}},
    {name = "Crucible of Battle", objectivesID = 16, draw = {
        --[[1]]{type = "triangle", color = "Red", position = "x"},
        --[[2]]{type = "triangle", color = "Teal", position = "-x"}}},
--Combat Patrol Missions
    {name = "(CP) Clash of Patrols", objectivesID = 17, draw = {
        --[[1]]{type = "line", color = "Red", position = "-z", fromCenter = 10 },
        --[[2]]{type = "line", color = "Teal", position = "z", fromCenter = 10, fromEdge = 0}}},
    {name = "(CP) Archeotech Recovery", objectivesID = 18, draw = {
        --[[1]]{type = "line", color = "Red", position = "x", fromCenter = 12 },
        --[[2]]{type = "line", color = "Teal", position = "-x", fromCenter = 12, fromEdge = 0}}},
    {name = "(CP) Forward Outpost", objectivesID = 19, draw = {
        --[[1]]{type = "line", color = "Red", position = "x", fromCenter = 12 },
        --[[2]]{type = "line", color = "Teal", position = "-x", fromCenter = 12, fromEdge = 0}}},
    {name = "(CP) Scorched Earth", objectivesID = 20, draw = {
        --[[1]]{type = "triangle", color = "Red", position = "x"},
        --[[2]]{type = "triangle", color = "Teal", position = "-x"}}},
    {name = "(CP) Sweeping Raid", objectivesID = 21, draw = {
        --[[1]]{type = "line", color = "Red", position = "x", fromCenter = 12 },
        --[[2]]{type = "line", color = "Teal", position = "-x", fromCenter = 12, fromEdge = 0}}},
    {name = "(CP) Display of Might", objectivesID = 22, draw = {
        --[[1]]{type = "line", color = "Red", position = "x", fromCenter = 12 },
        --[[2]]{type = "line", color = "Teal", position = "-x", fromCenter = 12, fromEdge = 0}}},
    {name = "None", draw = {type = "none"}},
}

deployLineHeight = 2.1
deployLineYPos = deployLineHeight-0.1
sizeMulti = 36

function drawDeployZone(zone)
    local drawDataZone = zone.draw
    for i, drawData in ipairs(drawDataZone) do
        if drawData.type == "arrow" then
            drawArrow(drawData)
        end
        if drawData.type == "line" then
            drawLine(drawData)
        end
        if drawData.type == "quarter" then
            drawQuarter(drawData)
        end
        if drawData.type == "diagonal" then
            drawDiagonal(drawData)
        end
        if drawData.type == "rectangle" then
            drawRectangle(drawData)
        end
        if drawData.type == "corner" then
            drawCorner(drawData)
        end
        if drawData.type == "triangle" then
            drawTriangle(drawData)
        end
        if drawData.type == "circle" then
            drawCircle(drawData, "deployZone")
        end
        if drawData.type == "circleInZone" then
            drawCircleInZone(drawData, "deployZone")
        end
    end
    setDeployHeight()
end

function setDeployHeight()
    local pos = {0,0,0}
    local found_GUID = {}
    for i, obj in ipairs(getAllObjects()) do
        if obj.getGMNotes() == "deployZone" then
            table.insert(found_GUID, #found_GUID+1, obj.getGUID())
        end
    end
    local found= nil
    for j, guid in ipairs(found_GUID) do
        found=getObjectFromGUID(guid)
        pos = found.getPosition()
        found.setPosition({pos[1], defaultDeployHeight+ deployOffset, pos[3]})
    end
end


function drawRectangle(drawData)
    local mat = getObjectFromGUID(mat_GUID)
    local linePosL = {x = 0, y = deployLineYPos, z = 0}
    local lineRotL = {x = 0, y = 90, z = 0}
    local lineScaleL = {x = 5, y = deployLineHeight, z = 0.02}
    local linePosS1 = {x = 0, y = deployLineYPos, z = 0}
    local lineRotS1 = {x = 0, y = 0, z = 0}
    local lineScaleS1 = {x = 5, y = deployLineHeight, z = 0.02}
    local linePosS2 = {x = 0, y = deployLineYPos, z = 0}
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "z" or drawData.position == "-z" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end
    if drawData.wide ~= 0 then
        mapBase = drawData.wide * 2
    end

    lineScaleL.x = drawData.wide * 2
    linePosL.x = drawData.fromCenter

    lineScaleS1.x = (mapHeight/2)-drawData.fromCenter
    linePosS1.x = drawData.fromCenter + ((mapHeight/2) - drawData.fromCenter)/2
    linePosS1.z = drawData.wide

    linePosS2.x = linePosS1.x
    linePosS2.z = -linePosS1.z

    if drawData.position == "x" then
        -- default values
    end
    if drawData.position == "-x" then
            linePosL.x = - linePosL.x
            linePosS2.x = -linePosS2.x
            linePosS1.x = -linePosS1.x
    end
    if drawData.position == "z" then
        linePosL.z = linePosL.x
        linePosL.x = 0
        lineRotL.y = 0

        local tmp = linePosS1.z
        linePosS1.z = linePosS1.x
        linePosS1.x = tmp
        lineRotS1.y = 90

        linePosS2.z = linePosS1.z
        linePosS2.x = -tmp

    end
    if drawData.position == "-z" then
        linePosL.z = -linePosL.x
        linePosL.x = 0
        lineRotL.y = 0

        local tmp = linePosS1.z
        linePosS1.z = -linePosS1.x
        linePosS1.x = -tmp
        lineRotS1.y = 90

        linePosS2.z = linePosS1.z
        linePosS2.x = tmp

    end
    spawnLine(linePosL, lineRotL, lineScaleL, drawData.color, "deployZone") -- orizz
    spawnLine(linePosS1, lineRotS1, lineScaleS1, drawData.color,  "deployZone") -- vert1
    spawnLine(linePosS2, lineRotS1, lineScaleS1, drawData.color, "deployZone") -- vert2
end

function drawCorner(drawData)
    local mat = getObjectFromGUID(mat_GUID)
    local linePosL = {x = 0, y = deployLineYPos, z = 0}
    local lineRotL = {x = 0, y = 0, z = 0}
    local lineScaleL = {x = 5, y = deployLineHeight, z = 0.02}
    local linePosS1 = {x = 0, y = deployLineYPos, z = 0}
    local lineRotS1 = {x = 0, y = 90, z = 0}
    local lineScaleS1 = {x = 5, y = deployLineHeight, z = 0.02}
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "x" or drawData.position == "-x" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end
    --print("MAP BxH: "..mapBase.." x "..mapHeight)
    lineScaleL.x = (mapHeight/2) + drawData.wide
    linePosL.x = (mapHeight/4)-(drawData.wide/2)
    linePosL.z = drawData.fromCenter

    lineScaleS1.x = (mapBase/2)-drawData.fromCenter
    linePosS1.z = drawData.fromCenter + lineScaleS1.x/2
    linePosS1.x = -drawData.wide

    if drawData.position == "z" then
        -- default values
    end
    if drawData.position == "-z" then
            linePosL.x = - linePosL.x
            linePosL.z = - linePosL.z

            linePosS1.z = -linePosS1.z
            linePosS1.x = -linePosS1.x
    end
    if drawData.position == "x" then -- not valid, to do
        linePosL.z = linePosL.x
        linePosL.x = 0
        lineRotL.y = 0

        local tmp = linePosS1.z
        linePosS1.z = linePosS1.x
        linePosS1.x = tmp
        lineRotS1.y = 90
    end
    if drawData.position == "-x" then-- not valid, to do
        linePosL.z = -linePosL.x
        linePosL.x = 0
        lineRotL.y = 0

        local tmp = linePosS1.z
        linePosS1.z = -linePosS1.x
        linePosS1.x = -tmp
        lineRotS1.y = 90
    end
    spawnLine(linePosL, lineRotL, lineScaleL, drawData.color, "deployZone") -- long
    spawnLine(linePosS1, lineRotS1, lineScaleS1, drawData.color,  "deployZone") -- short
end

function drawDiagonal(drawData)
    local mat = getObjectFromGUID(mat_GUID)
    local linePos = {x = 0, y = deployLineYPos, z = 0}
    local lineRot = {x = 0, y = 0, z = 0}
    local lineScale = {x = 5, y = deployLineHeight, z = 0.02}
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "x" or drawData.position == "-x" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end
    local mainDiagonal = 0
    local edgeLoss = 0
    local triBase = 0 -- triangle with hypotenuse as the needed deploy line

    local edgeAngle = 0 -- angle of the line from the given map edge
    local edgeAngleRad = 0
    local halfTriBase = 0 -- triangle with hypotenuse that is half the line lenght
    local halfTriHeight = 0 -- triangle with hypotenuse that is half the line lenght
    mainDiagonal = math.sqrt(math.pow(mapBase, 2) + math.pow(mapHeight, 2))
    edgeAngleRad = math.atan(mapBase / mapHeight)
    edgeAngle = math.deg(edgeAngleRad)
    edgeLoss = drawData.fromCenter / math.cos(edgeAngleRad)
    triBase = mapBase-edgeLoss
    local ratio = triBase / mapBase
    lineScale.x = mainDiagonal * ratio
    lineRot.y = edgeAngle
    halfTriBase = lineScale.x * math.sin(edgeAngleRad) / 2
    halfTriHeight = lineScale.x * math.cos(edgeAngleRad) / 2
    linePos.x = (mapHeight/2) - (lineScale.x/2) * math.cos(edgeAngleRad)
    linePos.z = (mapBase/2) - (lineScale.x/2) * math.sin(edgeAngleRad)
    if drawData.position == "z" then -- upper right
        -- default values
    end
    if drawData.position == "-z" then
        linePos.x = - linePos.x
        linePos.z = - linePos.z
    end
    spawnLine(linePos, lineRot, lineScale, drawData.color,  "deployZone")
end

function drawTriangle(drawData)
    local mat = getObjectFromGUID(mat_GUID)
    local linePos = {x = 0, y = deployLineYPos, z = 0}
    local lineRot = {x = 0, y = 0, z = 0}
    local lineScale = {x = 5, y = deployLineHeight, z = 0.02}
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "z" or drawData.position == "-z" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end

    local triBase = 0 -- triangle with hypotenuse as the needed deploy line
    local triHeight = 0 -- triangle with hypotenuse as the needed deploy line

    local edgeAngle = 0 -- angle of the line from the given map edge
    local edgeAngleRad = 0

    triBase = mapBase
    triHeight = mapHeight/2
    edgeAngleRad = math.atan(triBase/triHeight )
    if drawData.position == "z" or drawData.position == "-z" then
        edgeAngleRad = -edgeAngleRad
    end
    edgeAngle = math.deg(edgeAngleRad)
    lineScale.x = math.sqrt(triBase^2+triHeight^2)
    lineRot.y = edgeAngle

    if drawData.position == "x" then
        linePos.x=mapHeight/4
        linePos.z=0
    end
    if drawData.position == "-x" then
        linePos.x=-mapHeight/4
        linePos.z=0
    end
    if drawData.position == "z" then
        lineRot.y= lineRot.y-90
        linePos.x=0
        linePos.z=mapHeight/4
    end
    if drawData.position == "-z" then
        lineRot.y= lineRot.y+90
        linePos.x=0
        linePos.z=-mapHeight/4
    end
    spawnLine(linePos, lineRot, lineScale, drawData.color,  "deployZone")
end

function drawQuarter(drawData)
    local mat = getObjectFromGUID(mat_GUID)
    local linePos = {x = 0, y = deployLineYPos, z = 0}
    local lineRot = {x = 0, y = 90, z = 0}
    local lineScale = {x = 5, y = deployLineHeight, z = 0.02}
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "x" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end
    lineScale.x = (mapBase/2)-drawData.fromCenter
    linePos.z =  (lineScale.x/2) + drawData.fromCenter
    if drawData.position == "xz" then
        -- default values
    end
    if drawData.position == "x-z" or drawData.position == "-x-z" then
        linePos.z = -linePos.z
    end
    spawnLine(linePos, lineRot, lineScale, drawData.color,  "deployZone") -- short line
    lineScale.x = (mapHeight/2)-drawData.fromCenter
    linePos.z = 0
    linePos.x =  (lineScale.x/2) + drawData.fromCenter
    lineRot.y = 0
    if drawData.position == "-xz" or drawData.position == "-x-z" then
        linePos.x = -linePos.x
    end
    spawnLine(linePos, lineRot, lineScale, drawData.color, "deployZone") -- long line
end

function drawCircle(drawData, type)
    local originalCircle=getObjectFromGUID(Global.getVar("centerCircle_GUID"))
    local circleObj = originalCircle.clone({ position = {0, -5, 0}})
    if circleObj then
        circleObj.setLock(true)
        circleObj.setScale({drawData.fromCenter, deployLineHeight, drawData.fromCenter})
        circleObj.setPosition({0, deployLineYPos, 0})
        circleObj.setColorTint(drawData.color)
        circleObj.setGMNotes(type)
        circleObj.setName("")
        local blockComp = circleObj.getComponent("BoxCollider")
        blockComp.set("enabled", false)
    end
end

function drawCircleInZone(drawData, type)
    local mat = getObjectFromGUID(mat_GUID)
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "z" or drawData.position == "-z" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end
    local posX=0
    local posZ=0
    if drawData.position == "x" then
        posX=((mapHeight/2-drawData.deployFromCenter)/2)+drawData.deployFromCenter
    end
    if drawData.position == "-x" then
        posX=-((mapHeight/2-drawData.deployFromCenter)/2)+drawData.deployFromCenter
    end
    if drawData.position == "z" then
        posZ=((mapHeight/2-drawData.deployFromCenter)/2)+drawData.deployFromCenter
    end
    if drawData.position == "-z" then
        posZ=-((mapHeight/2-drawData.deployFromCenter)/2)+drawData.deployFromCenter
    end
     drawCircleNotCentered(drawData, type, posX,posZ)
end

function drawCircleNotCentered(drawData, type, centerX, centerZ)
    local originalCircle=getObjectFromGUID(Global.getVar("centerCircle_GUID"))
    local circleObj = originalCircle.clone({ position = {0, -5, 0}})
    if circleObj then
        circleObj.setLock(true)
        circleObj.setScale({drawData.fromCenter, deployLineHeight, drawData.fromCenter})
        circleObj.setPosition({centerX, deployLineYPos, centerZ})
        circleObj.setColorTint(drawData.color)
        circleObj.setGMNotes(type)
        circleObj.setName("")
        local blockComp = circleObj.getComponent("BoxCollider")
        blockComp.set("enabled", false)
    end
end

function drawLine(drawData)
    local mat = getObjectFromGUID(mat_GUID)
    local linePos = {x = 0, y = deployLineYPos, z = 0}
    local lineRot = {x = 0, y = 90, z = 0}
    local lineScale = {x = 5, y = deployLineHeight, z = 0.02}
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "z" or drawData.position == "-z" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end
    if drawData.fromSide then
        if drawData.fromSide ~= 0 then
            drawData.fromCenter = (mapBase/2)-drawData.fromSide
        end
    end
    lineScale.x = mapBase
    linePos.x = drawData.fromCenter
    if drawData.position == "x" then
        -- defaut values
    end
    if drawData.position == "-x" then
        linePos.x = -linePos.x
    end
    if drawData.position == "z" then
        lineRot.y = 0
        linePos.z = linePos.x
        linePos.x = 0
    end
    if drawData.position == "-z" then
        lineRot.y = 0
        linePos.z = -linePos.x
        linePos.x = 0
    end
    spawnLine(linePos, lineRot, lineScale, drawData.color, "deployZone")
end

function drawArrow(drawData)
    local mat = getObjectFromGUID(mat_GUID)
    local linePos = {x = 0, y = deployLineYPos, z = 0}
    local lineRot = {x = 0, y = 0, z = 0}
    local lineScale = {x = 5, y = deployLineHeight, z = 0.02}
    local mapBase =  mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge
    if drawData.position == "z" or drawData.position == "-z" then
        mapBase = mat.getScale().x * sizeMulti
        mapHeight = mat.getScale().z * sizeMulti
    end
    if drawData.wide ~= 0 then
        mapBase = drawData.wide *2
    end
    local triBase = (mapBase / 2) -- triangle with hypotenuse as the needed deploy line
    local triHeight = (mapHeight / 2) - drawData.fromCenter - drawData.fromEdge -- triangle with hypotenuse as the needed deploy line
    local edgeAngle = 0 -- angle of the line from the given map edge
    local edgeAngleRad = 0
    local halfTriBase = 0 -- triangle with hypotenuse that is half the line lenght
    local halfTriHeight = 0 -- triangle with hypotenuse that is half the line lenght
    lineScale.x = math.sqrt(math.pow(triBase, 2) + math.pow(triHeight, 2))
    edgeAngleRad = math.atan(triBase / triHeight)
    edgeAngle = math.deg(edgeAngleRad)
    lineRot.y = edgeAngle
    halfTriBase = (lineScale.x / 2) * math.sin(edgeAngleRad)
    halfTriHeight = (lineScale.x  / 2 ) * math.cos(edgeAngleRad)
    linePos.x = triHeight - halfTriHeight + drawData.fromCenter
    linePos.z = -1 * (triBase - halfTriBase)
    if drawData.position == "x" then
        --default values
    end
    if drawData.position == "-x" then
        linePos.z = -linePos.z
        linePos.x = -linePos.x
    end
    if drawData.position == "z" then
        local tmp = linePos.z
        linePos.z = linePos.x
        linePos.x = -tmp
        lineRot.y = 90 + lineRot.y
    end
    if drawData.position == "-z" then
        local tmp = linePos.z
        linePos.z = -linePos.x
        linePos.x = tmp
        lineRot.y = 90 + lineRot.y
    end

    spawnLine(linePos, lineRot, lineScale, drawData.color, "deployZone")
    if drawData.position == "x" or drawData.position == "-x"  then
        linePos.z = -linePos.z
        lineRot.y = -lineRot.y
    end
    if drawData.position == "z" or drawData.position == "-z"  then
        linePos.x = -linePos.x
        lineRot.y = -lineRot.y
    end
    spawnLine(linePos, lineRot, lineScale, drawData.color, "deployZone")
end

function spawnLine(linePos, lineRot, lineScale, color, type)
    local lineObj = spawnObject({ --Chip_10
        type = "BlockSquare",
        position = linePos,
        rotation = lineRot,
        scale = lineScale,
    })
    if lineObj then
        lineObj.setLock(true)
        lineObj.setGMNotes(type)
        lineObj.setColorTint(color)
        local blockComp = lineObj.getComponent("BoxCollider")
        blockComp.set("enabled", false)
    end
end

function destroyDeployZones()
    for i, obj in ipairs(getAllObjects()) do
        if obj.getGMNotes() == "deployZone" then
            obj.destroy()
        end
    end
end

function disableCollidersDeployZones()
    for i, obj in ipairs(getAllObjects()) do
        if obj.getGMNotes() == "deployZone" or obj.getGMNotes() == "areaDeny" or obj.getGMNotes() == "quarter" then
            local blockComp = obj.getComponent("BoxCollider")
            blockComp.set("enabled", false)
        end
    end

end
-- END deploy zones MANAGER


simulation = false -- is used to test in single player
redFirstLbl = "R  e  d    p l a y e r    f i r s t\n(click to toggle)"
blueFirstLbl = "B l u e    p l a y e r    f i r s t\n(click to toggle)"
inGame = false
gameTurnCounter = nil
armyMover = ""
first = "Red"
currentTurn = "Red"
cpEveryTurn = true

-- track if player has gained CP so far this battle round
-- true if a CP has been gained, else false
redCpIncrementTracker = false
blueCpIncrementTracker = false

phases = {"Command", "Movement", "Shooting", "Charge", "Fight"}
currentPhase = 1
startBtn = {
    index = 1, label = "S T A R T  G A M E", click_function = "startGame", function_owner = self,
    position = {0, 5, - 1}, rotation = {0, 0, 0}, height = 750, width = 5000,
    font_size = 500, color = {0, 0.6, 0}, font_color = {1, 1, 1}
}
firstPlayerBtn = {
    index = 1, label = redFirstLbl, click_function = "togglePlyr", function_owner = self,
    position = {0, 5, 1}, rotation = {0, 0, 0}, height = 750, width = 5000,
    font_size = 300, color = {1, 0, 0}, font_color = {1, 1, 1}
}
nextPhaseLbl = "P A S S\nT U R N"
nextPhaseBtn = {
    index = 1, label = nextPhaseLbl, tooltip = "Left click - Next phase\nRight click - Skip to next turn", click_function = "nextPhase", function_owner = self,
    position = {0, 5, 0}, rotation = {0, 0, 0}, height = 1500, width = 5000,
    font_size = 600, color = {1, 0, 0}, font_color = {1, 1, 1}
}
IncrementRedCpBtn = {
    index = 1, label = "Gain a CP", tooltip = "Increment Red CP counter\nWill only increment once per Round", click_function = "incrementRedCp", function_owner = self,
    position = {-46.2, 5, -3.75}, rotation = {0, 0, 0}, height = 1650, width = 3000,
    font_size = 600, color = {1, 0, 0}, font_color = {1, 1, 1}
}
IncrementBlueCpBtn = {
    index = 1, label = "Gain a CP", tooltip = "Increment Blue CP counter\nWill only increment once per Round", click_function = "incrementBlueCp", function_owner = self,
    position = {46.2, 5, -3.75}, rotation = {0, 0, 0}, height = 1650, width = 3000,
    font_size = 600, color = {0, 0, 1}, font_color = {1, 1, 1}
}

notePadTxt = "This is the Forty Thousand Collection 'FTC' gaming template for Warhammer 40k, version 2.0+, competitive fork. Only Grand Tournament play is supported.\n\nPlease raise issues at https://github.com/ThePants999/tts-comp-ftc-base-lua-scripts/issues.\n\nInstructions can be found in the Notebook.\n\nSearch for FTC or BCB Map Additive Load on the workshop for maps to load!\n\n\nJoin the TTS 40K Discord server: https://discord.gg/2ST7xyWgEa"
--
menuX = 18
menuZ = 1.05-1.05
arrowOffset = 7.5

-- DEPLOY ZONES VARIABLES

defaultDeployHeight=2
deployOffset = 0
deployMenuBtn = {
    index = 1, label = "Select deployment zones", click_function = "none", function_owner = self,
    position = { - menuX, 5, -1}, rotation = {0, 0, 0}, height = 750, width = 8000,
    font_size = 500, color = {0, 0, 0}, font_color = {1, 1, 1}
}

secondRowOffset= 1.2
deployBtn = {
    index = i, label = "", click_function = "none", function_owner = self,
    position = { - menuX, 5, 1}, rotation = {0, 0, 0}, height = 750, width = 6000,
    font_size = 400, color = {1, 1, 1}, font_color = {0, 0, 0}
}
deployUpBtn = {
    index = 1, label = "->", click_function = "deployUp", function_owner = self,
    position = { - menuX + arrowOffset, 5, 1}, rotation = {0, 0, 0}, height = 750, width = 800,
    font_size = 300, color = {0, 0, 0}, font_color = {1, 1, 1}
}
deployDownBtn = {
    index = 1, label = "<-", click_function = "deployDown", function_owner = self,
    position = { - menuX - arrowOffset, 5, 1}, rotation = {0, 0, 0}, height = 750, width = 800,
    font_size = 300, color = {0, 0, 0}, font_color = {1, 1, 1}
}
deployOffsetMenuBtn = {
    index = 1, label = "Deploy\nHeight", click_function = "none", function_owner = self,
    position = {-menuX - 1.4*arrowOffset, 5, menuZ}, rotation = {0, 0, 0}, height = 450, width = 1000,
    font_size = 150, color = {0, 0, 0}, font_color = {1, 1, 1}
}
deployOffsetUpBtn = {
    index = 1, label = "+", click_function = "deployOffsetUp", function_owner = self,
    position = {-menuX - 1.4*arrowOffset, 5, menuZ - secondRowOffset}, rotation = {0, 0, 0}, height = 450, width = 800,
    font_size = 300, color = {0, 0, 0}, font_color = {1, 1, 1}
}
deployOffsetDownBtn = {
    index = 1, label = "-", click_function = "deployOffsetDown", function_owner = self,
    position = {-menuX - 1.4*arrowOffset, 5, menuZ + secondRowOffset}, rotation = {0, 0, 0}, height = 450, width = 800,
    font_size = 300, color = {0, 0, 0}, font_color = {1, 1, 1}
}
objectivesOffsetMenuBtn = {
    index = 1, label = "Obj.\nHeight", click_function = "none", function_owner = self,
    position = {-menuX + 1.4*arrowOffset, 5, menuZ}, rotation = {0, 0, 0}, height = 450, width = 1000,
    font_size = 150, color = {0, 0, 0}, font_color = {1, 1, 1}
}
objectivesOffsetUpBtn = {
    index = 1, label = "+", click_function = "objectivesOffsetUp", function_owner = self,
    position = {-menuX + 1.4*arrowOffset, 5, menuZ - secondRowOffset}, rotation = {0, 0, 0}, height = 450, width = 800,
    font_size = 300, color = {0, 0, 0}, font_color = {1, 1, 1}
}
objectivesOffsetDownBtn = {
    index = 1, label = "-", click_function = "objectivesOffsetDown", function_owner = self,
    position = {-menuX + 1.4*arrowOffset, 5, menuZ + secondRowOffset}, rotation = {0, 0, 0}, height = 450, width = 800,
    font_size = 300, color = {0, 0, 0}, font_color = {1, 1, 1}
}


-- OBJECTIVES MANAGER
defaultObjectivesHeight=1.0

function spawnObjectives()
    destroyAllObjectives()
    if deploySelected < #DeployZonesData and DeployZonesData[deploySelected].objectivesID then
        for id, objectiveSet in ipairs(objectivesData) do
            if objectiveSet.id == DeployZonesData[deploySelected].objectivesID then
                local spawned = nil
                local pos={}
                local template = getObjectFromGUID(Global.getVar("templateObjective_GUID"))
                for i, objective in ipairs(objectiveSet.objectives) do
                    pos=objective.pos
                    if objectivesOffset == nil then pos[2] = 1 else pos[2] = defaultObjectivesHeight + objectivesOffset end
                    if objective.type=="fixed" then
                        -- no change to pos
                    end
                    if objective.type=="diagonal" then
                        pos=calcDiagonalPos(objective.orientation, pos[1], pos[2])
                    end
                    spawned = template.clone({ position = pos })
                    spawned.setGMNotes("objective")
                    spawned.setPosition(pos)
                    spawned.setRotation({0,270,180})
                    spawned.setLock(true)
                end
                break
            end
        end
    end
end

function calcDiagonalPos(orientation, relPosOnDiagonal, posY)
    local posX = 0
    local posZ = 0
    local mat = getObjectFromGUID(mat_GUID)
    local mapBase = mat.getScale().z * sizeMulti --short edge
    local mapHeight = mat.getScale().x * sizeMulti --long edge


    local edgeAngle = 0 -- angle of the line from the given map edge
    local edgeAngleRad = 0
    local halfTriBase = 0 -- triangle with hypotenuse that is half the line lenght
    local halfTriHeight = 0 -- triangle with hypotenuse that is half the line lenght

    edgeAngleRad = math.atan(mapBase / mapHeight)
    edgeAngle = math.deg(edgeAngleRad)

    posX=relPosOnDiagonal * math.cos(edgeAngleRad)
    posZ=relPosOnDiagonal * math.sin(edgeAngleRad)
    if orientation == "xz" then
        -- default values
    end
    if orientation == "x-z" then
        posZ=-posZ
    end
    if orientation == "-xz" then
        posX=-posX
    end
    if orientation == "-x-z" then
        posX=-posX
        posZ=-posZ
    end

    return {posX,posY,posZ}
end

function destroyAllObjectives()
    for i, obj in ipairs(getAllObjects()) do
        if obj.getGMNotes() == "objective" then
            obj.destroy()
        end
    end
end

function setObjectivesHeight()
    local pos = {0,0,0}
    local found_GUID = {}
    for i, obj in ipairs(getAllObjects()) do
        if obj.getGMNotes() == "objective" then
            table.insert(found_GUID, #found_GUID+1, obj.getGUID())
        end
    end
    local found= nil
    for j, guid in ipairs(found_GUID) do
        found=getObjectFromGUID(guid)
        pos = found.getPosition()
        found.setPosition({pos[1], defaultObjectivesHeight+ objectivesOffset, pos[3]})
    end
end
--END objectives manager

quartersPlaced = false
quartersLblOpen = "Hide\nTable Quarters"
quartersLblClosed = "Show\nTable Quarters"
quartersBtn = {
    label = quartersLblClosed, click_function = "showHideQuarters", function_owner = self,
    position = {menuX - 9, 5, menuZ }, rotation = {0, 0, 0}, height = 1500, width = 2600,
    font_size = 300, color = {1, 1, 1}, font_color = {0, 0, 0}
}
areaPlaced = false
areaLblOpen = "Hide\nArea Denial"
areaLblClosed = "Show\nArea Denial"
areaBtn = {
    label = areaLblClosed, click_function = "showHideAreaDeny", function_owner = self,
    position = {menuX - 3, 5, menuZ }, rotation = {0, 0, 0}, height = 1500, width = 2600,
    font_size = 300, color = {1, 1, 1}, font_color = {0, 0, 0}
}
engagePlaced = false
engageLblOpen = "Hide\nEngage"
engageLblClosed = "Show\nEngage"
engageBtn = {
    label = engageLblClosed, click_function = "showHideEngage", function_owner = self,
    position = {menuX + 3, 5, menuZ}, rotation = {0, 0, 0}, height = 1500, width = 2600,
    font_size = 300, color = {1, 1, 1}, font_color = {0, 0, 0}
}
stratreservesPlaced = false
stratreservesLblOpen = "Hide\nStrat Reserves"
stratreservesLblClosed = "Show\nStrat Reserves"
stratreservesBtn = {
    label = stratreservesLblClosed, click_function = "showHideStratreserves", function_owner = self,
    position = {menuX + 9, 5, menuZ}, rotation = {0, 0, 0}, height = 1500, width = 2600,
    font_size = 300, color = {1, 1, 1}, font_color = {0, 0, 0}
}
deploymentIngamePlaced = false
deployIngameLblOpen = "Hide\ndeployment\nzones"
deployIngameLblClosed = "Show\ndeployment\nzones"
deployIngameBtn = {
    index = 1, label = deployIngameLblClosed, click_function = "showHideIngameDeployment", function_owner = self,
    position = {menuX + 15, 5, menuZ}, rotation = {0, 0, 0}, height = 1500, width = 2600,
    font_size = 300, color = {1, 1, 1}, font_color = {0, 0, 0}
}
position = {menuX, 5, menuZ}

randomiseMissionBtn = {
    label = "Random\nMission",
    click_function = "randomiseMission",
    function_owner = self,
    position = {7, 5, -16.5},
    rotation = {0, 0, 0},
    height = 800,
    width = 2000,
    font_size = 200,
    color = {1, 1, 1},
    font_color = {0, 0, 0}
}
randomTournamentMissionBtn = {
    label = "Random\nTournament\nMission",
    click_function = "randomTournamentMission",
    function_owner = self,
    position = {11.5, 5, -16.5},
    rotation = {0, 0, 0},
    height = 800,
    width = 2000,
    font_size = 200,
    color = {1, 1, 1},
    font_color = {0, 0, 0}
}

function writeMenus()
    self.clearButtons()
    if not sizeConfirmed then
        writeSizeMenu()
        writeDeployMenu()
    else
        if inGame == false then
            writeStartMenu()
            writeDeployMenu()
        else
            writeIngameMenu()
        end
    end

end

function writeStartMenu()
    if gameMode ~= "game" then return end
    self.createButton(startBtn)
    self.createButton(firstPlayerBtn)
end

function writeDeployMenu()
    deployBtn.label = DeployZonesData[deploySelected].name
    self.createButton(deployBtn)
    self.createButton(deployUpBtn)
    self.createButton(deployDownBtn)
    self.createButton(deployOffsetMenuBtn)
    self.createButton(deployOffsetUpBtn)
    self.createButton(deployOffsetDownBtn)
    self.createButton(deployMenuBtn)
    self.createButton(objectivesOffsetDownBtn)
    self.createButton(objectivesOffsetUpBtn)
    self.createButton(objectivesOffsetMenuBtn)

    self.createButton(areaBtn)
    self.createButton(quartersBtn)
    self.createButton(engageBtn)
    self.createButton(stratreservesBtn)

    if gameMode == "game" then
        self.createButton(randomiseMissionBtn)
        self.createButton(randomTournamentMissionBtn)
    end
end

function writeIngameMenu()
    self.createButton(areaBtn)
    self.createButton(engageBtn)
    self.createButton(quartersBtn)
    self.createButton(stratreservesBtn)
    self.createButton(deployIngameBtn)
    self.createButton(IncrementRedCpBtn)
    self.createButton(IncrementBlueCpBtn)

    nextPhaseBtn.color = currentTurn
    local visibleTo=nextPhaseBtn.color
    Global.UI.setAttribute("passTurn", "visibility", visibleTo)
    Global.UI.setAttribute("passTurnBtn", "color", nextPhaseBtn.color)
    nextPhaseBtn.label = phases[currentPhase].."\nNEXT PHASE"
    if currentPhase == #phases then
        nextPhaseBtn.label = phases[currentPhase].."\nPASS TURN"
    end
    Global.UI.setValue("passTurnTxt", nextPhaseBtn.label)
    self.createButton(nextPhaseBtn)
end

function startGame(obj, player, alt)
    if alt then
        simulation = true
    end
    local playerList = Player.getPlayers()
    local numberOfPlayers = 0
    for i, p in ipairs(playerList) do
        numberOfPlayers = numberOfPlayers + 1
    end

    if Player["Red"].seated == false or Player["Blue"].seated == false then
        broadcastToAll("Must have both players seated", {1, 0, 0})
        if simulation == false then
            return
        end
    end
    Global.call("recordPlayers")
    inGame = true

    local scoresheet = getObjectFromGUID(Global.getVar("scoresheet_GUID"))
    scoresheet.call("startGame")

    startCustomTurns()
    destroyDeployZones()
    deploymentIngamePlaced = false
    areaPlaced = false
    broadcastToAll(phases[currentPhase].." phase", "Yellow")
    resetActivationTokens()
    Notes.setNotes("")
    writeMenus()
    simulation = false
end

function resetActivationTokens()
    for i, obj in ipairs(getAllObjects()) do
        if obj.getVar("BCBtype") == "ActivationToken" then
            obj.call("resetAlredyActed")
        end
    end
end

function newRoundStarted()
    redCpIncrementTracker = false
    blueCpIncrementTracker = false
end

function incrementRedCp(params)
    if not inGame then return end
    if not redCpIncrementTracker then
        redCpIncrementTracker = true
        redCpCounter.Counter.increment()
    else
        broadcastToAll("Red has already gained a CP this battle round!", "Yellow")
    end
end

function incrementBlueCp(params)
    if not inGame then return end
    if not blueCpIncrementTracker then
        blueCpIncrementTracker = true
        blueCpCounter.Counter.increment()
    else
        broadcastToAll("Blue has already gained a CP this battle round!", "Yellow")
    end
end

function nextPhase(obj, player_color_click, alt_click)
    resetActivationTokens()
    if alt_click then
        passTurn(obj, player_color_click, alt_click)
        return
    end
    currentPhase = currentPhase + 1
    if currentPhase > #phases then
        currentPhase = 1
        passTurn(obj, player_color_click, alt_click)
    end
    broadcastToAll(phases[currentPhase].." phase", "Yellow")
    writeMenus()
end

function passTurn(obj, player_color_click, alt_click)
    if player_color_click ~= currentTurn then

        if simulation then
            broadcastToAll("INTRUDER", "Pink")
        else
            return
        end

    end
    currentPhase = 1
    if currentTurn == "Red" then
        currentTurn = "Blue" -- it has to be the opposite
        blueTurnCounter.call("increaseSelf")
        blueCpCounter.Counter.increment()
        if cpEveryTurn then
          redCpCounter.Counter.increment()
          Wait.time(function() broadcastToAll("Both CPs incremented!", "White") end, 0.3)
        else
          Wait.time(function() broadcastToAll("Blue CPs incremented!", "Blue") end, 0.3)
        end
    else
        currentTurn = "Red"
        redTurnCounter.call("increaseSelf")
        redCpCounter.Counter.increment()
        if cpEveryTurn then
          blueCpCounter.Counter.increment()
          Wait.time(function() broadcastToAll("Both CPs incremented!", "White") end, 0.3)
        else
          Wait.time(function() broadcastToAll("Red CPs incremented!", "Red") end, 0.3)
        end
    end
    if simulation then
        broadcastToAll("It's "..currentTurn.." turn", currentTurn)
    else
        if Player[currentTurn].steam_name then
            broadcastToAll("It's "..Player[currentTurn].steam_name.." turn", currentTurn)
        else
            broadcastToAll("It's "..currentTurn.." turn", currentTurn)
        end
    end
    writeMenus()
end

function startCustomTurns()
    if first == "Red" then
        currentTurn = "Blue" -- it has to be the opposite
    else
        currentTurn = "Red"
    end
    passTurn(self, currentTurn, false)
end

function startBuiltinTurns()
    if first == "Red" then
        Turns.order = {"Red", "Blue"}
    else
        Turns.order = {"Blue", "Red"}
    end
    Turns.pass_turns = true
    Turns.enable = false
    Turns.enable = true
end

function togglePlyr()
    self.clearButtons()
    if first == "Red" then
        firstPlayerBtn.label = blueFirstLbl
        firstPlayerBtn.color = {0, 0, 1}
        first = "Blue"
    else
        firstPlayerBtn.label = redFirstLbl
        firstPlayerBtn.color = {1, 0, 0}
        first = "Red"
    end
    writeMenus()
end

function placeDeploy()
    destroyDeployZones()
    local data = DeployZonesData[deploySelected]
    drawDeployZone(data)
    if data.objectivesID then
        spawnObjectives()
    end
    writeMenus()
end

function deployUp()
    deployUpDown(true)
end

function deployDown()
    deployUpDown(false)
end

function deployUpDown(upDown)
    deployOffset = 0
    objectivesOffset = 0
    deploymentPregamePlaced = true
    if DeployZonesData[deploySelected].objectivesID then
        destroyAllObjectives()
    end
    local add=1
    if not upDown then
        add=-1
    end
    deploySelected = deploySelected + add
    if deploySelected > #DeployZonesData then
        deploySelected = 1
    end
    if deploySelected < 1 then
        deploySelected = #DeployZonesData
    end
    writeMenus()
    placeDeploy()
end

function deployOffsetUp()
    deployOffsetUpDown(true)
end

function deployOffsetDown()
    deployOffsetUpDown(false)
end

function deployOffsetUpDown(upDown) -- true up, false down
    local amt = 1
    if not upDown then amt = -1 end
    deployOffset = deployOffset + amt
    if deployOffset > 25 then
        deployOffset = 25
    end
    if deployOffset < 0 then
        deployOffset = 0
    end
    writeMenus()
    setDeployHeight()
end

function objectivesOffsetUp()
    objectivesOffsetUpDown(true)
end

function objectivesOffsetDown()
    objectivesOffsetUpDown(false)
end

function objectivesOffsetUpDown(upDown) -- true up, false down
    local amt = 0.2
    if not upDown then amt = -0.2 end
    objectivesOffset = objectivesOffset + amt
    if objectivesOffset > 25 then
        objectivesOffset = 25
    end
    if objectivesOffset < 0 then
        objectivesOffset = 0
    end
    writeMenus()
    setObjectivesHeight()
end


function showHideIngameDeployment()
    if deploymentIngamePlaced == false then -- place
        deployIngameBtn.label = deployIngameLblOpen
        if deploySelected < #DeployZonesData then
            drawDeployZone(DeployZonesData[deploySelected])
        end
        deploymentIngamePlaced = true
    else -- recall
        deployIngameBtn.label = deployIngameLblClosed
        if deploySelected < #DeployZonesData then
            destroyDeployZones()
        end
        deploymentIngamePlaced = false
    end
    writeMenus()
end

function showHideAreaDeny()
    if areaPlaced == false then -- place
        areaBtn.label = areaLblOpen
        drawCircle({color="White", fromCenter=6}, "areaDeny")
        drawCircle({color="White", fromCenter=3}, "areaDeny")
        areaPlaced = true
    else -- recall
        areaBtn.label = areaLblClosed
        for i, obj in ipairs(getAllObjects()) do
            if obj.getGMNotes() == "areaDeny" then
                obj.destroy()
            end
        end
        areaPlaced = false
    end
    writeMenus()
end

function showHideEngage()
    if not engagePlaced then
        engageBtn.label = engageLblOpen

        local mat = getObjectFromGUID(mat_GUID)
        local lineScale = {x = 0, y = deployLineHeight, z = 0.02}
        local mapBase = mat.getScale().z * sizeMulti -- short edge
        local mapHeight = mat.getScale().x * sizeMulti -- long edge

        -- Engage lines
        xLength = (mapHeight / 2) - 3
        zLength = (mapBase / 2) - 3
        lineScale.x = xLength
        --(linePos, lineRot, lineScale, color, orientation, type)
        spawnLine({(xLength / 2) + 3, deployLineHeight, -3}, {0, 0, 0}, lineScale, "White", "engage")
        spawnLine({(xLength / 2) + 3, deployLineHeight, 3}, {0, 0, 0}, lineScale, "White", "engage")
        spawnLine({((xLength / 2) * -1) - 3, deployLineHeight, -3}, {0, 0, 0}, lineScale, "White", "engage")
        spawnLine({((xLength / 2) * -1) - 3, deployLineHeight, 3}, {0, 0, 0}, lineScale, "White", "engage")
        lineScale.x = zLength
        spawnLine({-3, deployLineHeight, (zLength / 2) + 3}, {0, 90, 0}, lineScale, "White", "engage")
        spawnLine({3, deployLineHeight, (zLength / 2) + 3}, {0, 90, 0}, lineScale, "White", "engage")
        spawnLine({-3, deployLineHeight, (((zLength / 2) * -1) - 3)}, {0, 90, 0}, lineScale, "White", "engage")
        spawnLine({3, deployLineHeight, (((zLength / 2) * -1) - 3)}, {0, 90, 0}, lineScale, "White", "engage")

        engagePlaced = true
    else
        engageBtn.label = engageLblClosed

        for i, obj in ipairs(getAllObjects()) do
            if obj.getGMNotes() == "engage" then
                obj.destroy()
            end
        end
        engagePlaced = false
    end

    writeMenus()
end

function showHideQuarters()
    if quartersPlaced == false then -- place
        quartersBtn.label = quartersLblOpen
        local mat = getObjectFromGUID(mat_GUID)
        local lineScale = {x = 5, y = deployLineHeight, z = 0.02}
        local mapBase = mat.getScale().z * sizeMulti --short edge
        local mapHeight = mat.getScale().x * sizeMulti --long edge
        --(linePos, lineRot, lineScale, color, orientation, type)
        lineScale.x = mapHeight
        spawnLine({0, deployLineHeight, 0}, {0,0,0}, lineScale, "White", "quarter")
        lineScale.x = mapBase
        spawnLine({0, deployLineHeight ,0}, {0,90,0}, lineScale, "White", "quarter")
        quartersPlaced = true
    else -- recall
        quartersBtn.label = quartersLblClosed
        for i, obj in ipairs(getAllObjects()) do
            if obj.getGMNotes() == "quarter" then
                obj.destroy()
            end
        end
        quartersPlaced = false
    end
    writeMenus()
end

function showHideStratreserves()
    if not stratreservesPlaced then
        stratreservesBtn.label = stratreservesLblOpen

        local playerSides = "None"

        -- check that a deployment zone has been specified to determine which sides to colour
        if DeployZonesData[deploySelected].name ~= "None" then
            local deployZoneLayout = DeployZonesData[deploySelected].draw[1]
            playerSides = "long"

            -- check if deployment has short sides as Player Sides
            if deployZoneLayout["type"] == "line" and deployZoneLayout["position"] == "x" then
                playerSides = "short"
            elseif deployZoneLayout["type"] == "triangle" then
                playerSides = "short"
            end
        end

        local mat = getObjectFromGUID(mat_GUID)
        local lineScale = {x = 0, y = deployLineHeight, z = 0.02}
        local mapBase = mat.getScale().z * sizeMulti -- short edge
        local mapHeight = mat.getScale().x * sizeMulti -- long edge

        -- Strategic reserves lines
        --(linePos, lineRot, lineScale, color, orientation, type)
        lineScale.x = mapHeight

        if playerSides == "long" then
            spawnLine({0, deployLineHeight, (mapBase / 2) - 6}, {0, 0, 0}, lineScale, "Red", "stratreserves")
            spawnLine({0, deployLineHeight, -((mapBase / 2) - 6)}, {0, 0, 0}, lineScale, "Teal", "stratreserves")
        else
            spawnLine({0, deployLineHeight, (mapBase / 2) - 6}, {0, 0, 0}, lineScale, "White", "stratreserves")
            spawnLine({0, deployLineHeight, -((mapBase / 2) - 6)}, {0, 0, 0}, lineScale, "White", "stratreserves")
        end
        lineScale.x = mapBase

        if playerSides == "short" then
            spawnLine({(mapHeight / 2) - 6, deployLineHeight, 0}, {0, 90, 0}, lineScale, "Red", "stratreserves")
            spawnLine({-((mapHeight / 2) - 6), deployLineHeight, 0}, {0, 90, 0}, lineScale, "Teal", "stratreserves")
        else
            spawnLine({(mapHeight / 2) - 6, deployLineHeight, 0}, {0, 90, 0}, lineScale, "White", "stratreserves")
            spawnLine({-((mapHeight / 2) - 6), deployLineHeight, 0}, {0, 90, 0}, lineScale, "White", "stratreserves")
        end

        stratreservesPlaced = true
    else
        stratreservesBtn.label = stratreservesLblClosed

        for i, obj in ipairs(getAllObjects()) do
            if obj.getGMNotes() == "stratreserves" then
                obj.destroy()
            end
        end
        stratreservesPlaced = false
    end

    writeMenus()
end

--[[
GUID reference for primary / mission / deployment cards
Yeah, I could use variables but I didn't, oh well

Sites of Power ec78cd
Scorched Earth 3ad5a3
Purge the Foe 5444d4
Priority Targets f97708
Deploy Servo-Skulls 44ff29
Take and Hold 884291
Supply Drop a34ae1
The Ritual 646b49
Vital Ground 6fc1c2

Chilling Rain db0022
Hidden Supplies 0dc3c3
Scrambler Fields aea986
Chosen Battlefield 876ac7

Hammer and Anvil 117c77
Dawn of War 7e4b95
Sweeping Engagement 381d7c
Search and Destroy ad4220
Crucible of Battle 3c0679
]]--

tournamentMissions = {
    -- Take and Hold / Chilling Rain / Search and Destroy
    {primary = "884291", mission = "db0022", deployment = "ad4220"},
    -- Priority Targets / Hidden Supplies / Search and Destroy
    {primary = "f97708", mission = "0dc3c3", deployment = "ad4220"},
    -- The Ritual / Scrambler Fields / Sweeping Engagement
    {primary = "646b49", mission = "aea986", deployment = "381d7c"},
    -- Deploy Servo-skulls / Chilling Rain / Search and Destroy
    {primary = "44ff29", mission = "db0022", deployment = "ad4220"},
    -- Take and Hold / Chosen Battlefield / Sweeping Engagement
    {primary = "884291", mission = "876ac7", deployment = "381d7c"},
    -- Supply Drop / Chilling Rain / Search and Destroy
    {primary = "a34ae1", mission = "db0022", deployment = "ad4220"},
    -- Sites of Power / Chilling Rain / Hammer and Anvil
    {primary = "ec78cd", mission = "db0022", deployment = "117c77"},
    -- The Ritual / Chilling Rain / Hammer and Anvil
    {primary = "646b49", mission = "db0022", deployment = "117c77"},
    -- Take and Hold / Hidden Supplies / Hammer and Anvil
    {primary = "884291", mission = "0dc3c3", deployment = "117c77"},
    -- Priority Targets / Chilling Rain / Crucible of Battle
    {primary = "f97708", mission = "db0022", deployment = "3c0679"},
    -- Deploy Servo-skulls / Hidden Supplies / Crucible of Battle
    {primary = "44ff29", mission = "0dc3c3", deployment = "3c0679"},
    -- Scorched Earth / Chilling Rain / Dawn of War
    {primary = "3ad5a3", mission = "db0022", deployment = "7e4b95"},
    -- Purge the Foe / Chilling Rain / Crucible of Battle
    {primary = "5444d4", mission = "db0022", deployment = "3c0679"},
    -- Priority Targets / Chosen Battlefield / Dawn of War
    {primary = "f97708", mission = "876ac7", deployment = "7e4b95"},
    -- Vital Ground / Chilling Rain / Crucible of Battle
    {primary = "6fc1c2", mission = "db0022", deployment = "3c0679"}
}

function randomiseMission()
    Global.call("moveAllFromZoneToDeck", {zone = "deployment", deck = "deployment"})
    Global.call("moveAllFromZoneToDeck", {zone = "mission", deck = "mission"})
    Global.call("moveAllFromZoneToDeck", {zone = "primary", deck = "primary"})

    Global.call("moveOneFromDeckToZone", {deck = "deployment", zone = "deployment"})
    Global.call("moveOneFromDeckToZone", {deck = "mission", zone = "mission"})
    Global.call("moveOneFromDeckToZone", {deck = "primary", zone = "primary"})
end

function randomTournamentMission()
    Global.call("moveAllFromZoneToDeck", {zone = "deployment", deck = "deployment"})
    Global.call("moveAllFromZoneToDeck", {zone = "mission", deck = "mission"})
    Global.call("moveAllFromZoneToDeck", {zone = "primary", deck = "primary"})

    mission = tournamentMissions[math.random(#tournamentMissions)]
    Global.call("moveOneFromDeckToZone", {deck = "deployment", zone = "deployment", card = mission.deployment})
    Global.call("moveOneFromDeckToZone", {deck = "mission", zone = "mission", card = mission.mission})
    Global.call("moveOneFromDeckToZone", {deck = "primary", zone = "primary", card = mission.primary})
end

function recallAll()
    destroyAllObjectives()
    destroyDeployZones()
end

function none()
end
